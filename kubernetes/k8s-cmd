install docker
sudo usermod -aG docker $USER && newgrp docker
install kubectl
install minikube

minikube start
minkube start --memory=4096 --driver=hyperkit

kubectl get nodes
vi pod.yml  -> a pod is a specification on how to run your container
                (docker run -d nginx:1.14.2 --name nginx -p 80:80)
kubectl create -f pod.yml
kubectl apply -f pod.yml

kubectl describe pod nginx
kubectl logs nginx 

kubectl get pods -o wide   -> get IP -> or kubectl describe
minikube ssh  -> to login to minikube  or ssh -i IP_k8s-master -> if k8s
curl IP

kubectl delete pod nginx


---------------------------------------------------k8s deployment
kubectl get pods
kubectl get deploy
kubectl delete deploy nginx-deployment
kubectl get all
kubectl get all -A

create Deploy => Replicaset => Pods

vim deployment.yml
kubectl apply -f deployment.yml
kubectl get deploy
kubectl get pods
kubectl get rs   -> replicaset

kubectl delete pod nginx-deployment-985656-uyttr
kubectl get pods -w  -> watching: show you in live what is happening
 
vim deployment.yml
kubectl apply -f deployment.yml

-----------------------------------------------------k8s service

when you deploy a deployment, for each deploymet, you create a service
service works on the concept of label and selector
k8s service identify the pods using Selectors and Labels so every time a pod come up, label will remain the same
the selector match the label of the pod and a new pod is cretaed, which is identified by label , then traffic is sent as well

git clone repo
cd to repo
cd python-web-app (Dockerfile, app:devops, requirements.txt)
vim Dockerifle
docker build -t laly9999/python-app-demo:v1 .
docker login
docker push

vim deployment.yml  (give replicas, give selector and label name; give image repo/name; look container port in dockerfile:expose or cmd:8000)
kubectl apply -f deployment.yml
kubectl get deploy    -> (kubectl talk to k8s API server and get info of deploy )
kubectl get pods

kubectl get pods -o wide   -> get IP of the pods (172.17.0.5, 172.17.0.7)
kubectl get pods -v=7

minikube ssh
curl -L http://172.17.0.5:8000/demo  -> devops/devops/urls.py : urlpatterns = [path('demo/')]

--------------------------------------
expose your app to others people in your organization using nodeport

vim service.yml (type: nodeport, port:80, targetport:8000, nodeport:3007)
kubectl apply -f service.yml
kubectl get svc -v=9
kubectl get svc  -> cluster-ip=10.101.63.207
minikube ssh
curl -L http://10.101.63.207:80/demo -v
exit 

minikube ip  ->ip=192.168.64.10
curl -L http://192.168.64.10:3007/demo  or go to the browser
http://192.168.64.10:3007/demo
------------------------------------------
expose your app to others people outside your organization using loadbalancer supported by cloud, 
cloud control manager will generate a public ip address, then share to customer
kubectl get svc
kubectl edit svc service-name (change type to loadbalancer) 

---------------------------------------------------
service discovery

kubectl get svc
kubectl edit svc service-name or
vim service.yml (modify selector: app: eeeeeeeeeee and now it is different from the label in the deployment)
kubectl apply -f service.yml
http://192.168.64.10:3007/demo  app is not accessible, so this service is not discover

------------------------------------------------------

ingress

minikube addons enable ingress
kubectl get pods -A | grep nginx

vim ingress.yml
kubectl apply -f ingress.yml
kubectl logs ingress-nginx-controller-7799c6795f-8hkbg -n ingress-nginx
 kubectl get ingress

curl -L http://foo.bar.com/bar -v
ping foo.bar.com
sudo vim /etc/hosts
ping foo.bar.com
curl -L http://foo.bar.com/bar -v

